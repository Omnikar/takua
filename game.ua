# Experimental!

Flat â† 1
Wall â† 2
Cap  â† 3

â”Œâ”€â•´Board
  ~ {
    # All past board states
    History
    # The current board state
    State
    # Flat stones per player
    NFlats
    # Capstones per player
    NCaps
    # Portable Tak Notation log of the move history
    PTNRecord â† {}
  }
  PieceCount â† ËœâŠ[10_0 15_0 21_1 30_1 40_2 50_2]â†¥â‚€â†§5-3
  # Create a new Board
  # Board ? Size
  Call â† NewâŠƒ(Ëœâ†¯{}[0.]|â†¯ËœâŸœâ†¯â–¡[]|Â°âŠŸPieceCount)
  # The index of the current turn
  Turn         â† â§»History
  ActivePlayer â† â—¿â‚‚Turn
  # Check for a winning state by completed road for both players
  CheckRoadWin â† âŠŸâˆ©(
    ğ„âŒŸ:âŠ¸â‰â†¯âŠ¸â§»+Ã—2âŠ¸â‡Œ=â‚€Â°âŠ
    /âˆ¨=â‚ƒâŠ‚âŠœâˆ©(/+â—´)âˆŠFlat_Capâ‰¡â‚€â—‡â¬š0âŠ¢
  )âŸœÂ¯ State
  # Check for a flat win/draw when the board is filled or one player runs out of pieces
  CheckFlatWin â† (
    â™­âŠƒ(State|NFlats|NCaps)
    â£(â¤šâ£(
        Â°0â†§âˆ©âŒŸâ‚‚(â†¥Ëœâˆ©-âˆ©/+âŠƒ(âˆŠFlat_Wall|=Cap)/â—‡âŠ‚â†¥â‚€)âŸœÂ¯
      | Â°1/Ã—Â±â‰¡â—‡â§»)
      âŠŸâŠƒâ‰¤â‰¥âˆ©/+âˆ©âŒ=FlatâŸœÂ¯â‰¡â—‡â¬š0âŠ¢
    )0_0
  )
â””â”€â•´

â”Œâ”€â•´Action
  # New move that has not been built yet
  |Uninit
  # Place a new piece on the board
  |Place {
    # The piece type to place
    Piece
    # The position to place at
    Pos
  }
  # Move existing pieces
  |Move {
    # The number of pieces to move
    Num
    # The direction to move in
    Dir
    # The amounts of pieces dropped at each step
    Amnts
    # The position the pieces are picked up from
    Orig
  }
  New â† Uninit

  SwitchPlacement â†š (
    # If already placing and clicking on the same square,
    # increment the piece type to be placed
    âœ(-â‚Â°Place
    | âŠ™Â°.
      â—¡â‹…â‹…Board!âŠƒ(State|NFlats|NCaps)
      Ëœâˆ©>âˆ©/+âŠ¸Â¬=â‚ƒâ–½âŠ¸Â±/â—‡âŠ‚â™­
      â¨¬(-â‚â‹…CapÂ°1)â¨¬(â—¿â‚‚+â‚|â—¿â‚ƒ+â‚)
    ):
  )

  PickUpPieces â†š Move!(
    # If moving and clicking on the origin square
    Â°.â—¡â‹…Orig
    # And nowhere else has been clicked already
    Â°[]â—¡â‹…Amnts
    # Min number of stones and carry limit
    ğ„âŒ(â†§â—‡âˆ©â§»âŠ¸âŠ¡âŠ™âŠ¸Board~State)
    # Increment the number of stones being
    # carried and limit accordingly
    âœNum(â†§+â‚)
  )

  MovePieces â†š Move!(
    â—¡â‹…Dir

    TryMove â† (
      âŠ¡âŠ™â—¡â‹…Board~State
      # Ensure that the piece being moved
      # onto is not a capstone
      Â°1âŠ¸<CapâŒµâ—‡â¬š1âŠ¢
      # If it is a wall, ensure the piece
      # being moved is a lone capstone
      >Flat
      â¥(Â°1-/+âŠ¸âŠƒAmnts Num
        Â°Capâ—‡âŠ¢âŠ¡â—¡âŠ“Orig Board~State)

      âœAmnts(âŠ‚1)
    )

    â£(â—¡â‹…Orig Â°0_0
      ğ„âŒÂ°âŠ¸Dir â©Â°1âŠ¸âˆŠAâ‚‚âŠ¸-
      TryMove
    | âŠ™(âŠ¸-+Ã—â§»â—¡â‹…âŠƒ(Amnts|Dir|Orig))
      â£(TryMoveâ—ŒÂ°.|â‹…âœ(âŠ¢Amnts)+â‚â‹…Â°0_0))

    Â°1â‰¥/+âŠ¸Move!âŠƒAmnts Num
  )

  ClickSquareImpl â†š |3.2 (
    â£( # If a move hasn't been started yet
      Â°Uninit :
      # Check if the square is occupied
      âŠ¡â—¡âŠ™Board~State
      # If empty, start a place
      # Otherwise, check that the active player
      # controls this square and start a move
      â£(Move 1 0_0 [] â©Â°1Â±â—‡âŠ¢|ClickSquareImplâ¤™Placeâ‹…0)
    | SwitchPlacement
    | PickUpPieces
    | MovePieces
    | # If nothing else works, restart the move and try again
      â¨¬(ClickSquareImpl âŠ™â‹…Uninit)â—Œ â‰UninitâŠ¸:
    )

    # Opponents place each other's flats on the first two turns
    <2â—¡â‹…Board~Turn
    â¥â£(Â°âŠ¸Place~PieceÂ¯1|â‹…Uninit)
  )

  ClickSquare â† (
    # Change between positive representing player 1 and representing the active player
    FlipPlayerâ‚‚ â† (âŒ…(^0|^0))!(
      â—¡â‹…Board~ActivePlayer
      â¥âŠ“â£âœPlace~PieceÂ¯âˆ˜âœBoard~StateÂ¯
    )

    âœâŠ™FlipPlayerâ‚‚ ClickSquareImpl
  )

  # Format a move in Portable Tak Notation
  Fmt â† (
    FmtPos â† âŒ…($"__"Ëœâˆ©+@a1Â°âŠŸ|âœÂ°âŠŸâŠ“(-@a|-â‚â‹•))
    âŒ…(â£(""Â°Uninit
      | âŒµÂ°Place
        âŠ‚âŠ“â£(
          ""Â°Flat
        | "S"Â°Wall
        | "C"Â°Cap
        )FmtPos
      | âŠ™ğ„âŒŸ:Â°Move
        /â—‡âŠ‚{âŠ“(â£(""Â°1)Â°â‹•|FmtPos|ËœâŠ"+>-<"ËœâŠ—Aâ‚‚|â£(""Â°1â§»|Â°â‹•Â°âŠ¥â‚â‚€))})
    | â£(â†˜â‚âŠ¢regex"([1-9]*)([a-h][1-8])([+>\\-<])([1-9]*).*?"
        â¬š1â‹•Â°â–¡â‚„
        âŠƒâŠ™âŠ“Â°FmtPos(ËœâŠ¡Aâ‚‚âŠ—âŠ™"+>-<")ğ„ğ„(âŠ¥â‚â‚€â¬šâˆ˜â‹•)
        MoveâŠ™â¤šâ‹…âŠ™âˆ˜
      | â†˜â‚âŠ¢regex"([SC]?)([a-h][1-8]).*?"
        Place âŠ“(+â‚âŠ—âŠ™"FSC"â¬š@FâŠ¢)Â°FmtPos Â°â–¡â‚‚)
    )
  )

  # Actions ? PTNString
  ParsePTN â† (
    # Strip metadata
    â¢âˆ˜â£(1â—ŒÂ°$"[_]\n_")0

    âŠœâ–¡Â¬âŠ¸âˆŠ" \n"
    âˆ©âŒŸâ–½âŸœÂ¬Â±â—¿â‚ƒÂ°âŠ
    :âšÂ°Fmt
    â‰ âŸœ(â†™â§»)â—¿â‚‚â‡¡â—¡â‹…â§»â–½2=â–¡"1."
    âšâ¥â£âœPlace~PieceÂ¯âˆ˜
  )
â””â”€â•´

# Transform board state based on a move
â”Œâ”€â•´Process
  # Process a placement
  ProcessPlace â† (
    Action~Place!âŠƒPos Piece
    ËœâŒŸâœ(Â°â–¡âŠ¡âŠ™Board~State)âŠ‚
  )
  # Process a movement
  ProcessMove â† Action~Move!âŸœâ†“(
    âŠƒNum Orig
    âœâŠ™âŠ™(Â°â–¡âŠ¡|Board~State)âŠƒâ†™â†˜
  | âŠƒ(â‡ŒAmnts|Â¤Dir|Orig)
    âˆ§(âŠƒâ†˜â†™Â¯âŠ™:âŠ™+
      âŠƒâ‹…â‹…âˆ˜âŠ™âœâŠ™(Â°â–¡âŠ¡âŠ™Board~State)âŠ‚)
    â‹…â—Œ
    # Flatten walls
    âœBoard~Stateâšâ‚€âœ(âŒµâ†˜â‚|â†§Flat)
  )
  # Assert that a move is completely formed
  Validate â† Â°1âŠ¸Action!â£(0Â°Uninit|=/+Move!âŠƒAmnts Num|1)
  Call â† (
    Validate
  
    # PTN OldState Board ? Action Board
    âŠƒâŠ“Action~Fmt Board~Stateâ£ProcessPlace ProcessMove
  
    # Check if a wall was flattened, appending an asterisk to the PTN if so
    â—¡â‹…âŠ™Board~State
    /âˆ¨â™­Ã—Ëœâˆ©=Wall Capâˆ©(âŒµâ‰¡â‚€â—‡â¬š0âŠ¢)
    â¤™âŠ™âŠ™â—Œ â–¡â¥(ËœâŠ‚@*)
  
    âœBoard~PTNRecordâŠ‚
    âœBoard~HistoryâŠ‚
  )
â””â”€â•´
